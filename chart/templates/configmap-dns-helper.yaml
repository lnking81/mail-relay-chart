{{- if .Values.dnsHelper.enabled }}
{{- /* Effective IP detection flag and external IPs using helpers */ -}}
{{- $ipDetection := eq (include "mail-relay.dnsHelper.ipDetection" .) "true" -}}
{{- $externalIps := .Values.dnsHelper.externalIps | default (list) -}}

apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "mail-relay.fullname" . }}-dns-helper
  labels:
    {{- include "mail-relay.labels" . | nindent 4 }}
data:
  dns-records.md: |
    # DNS Records for {{ .Values.mail.hostname }}

    This file contains the DNS records you need to configure for your mail relay.

    ## Automatic Records (via external-dns)
    {{- if .Values.externalDns.enabled }}

    The following record is automatically managed:
    - A record: {{ include "mail-relay.externalDnsHostname" . }} ‚Üí <LoadBalancer-IP>
    {{- else }}

    External DNS is disabled. You need to manually create:
    - A record: {{ .Values.mail.hostname }} ‚Üí <EXTERNAL-IP>
    {{- end }}

    ## Manual Records Required

    {{- range .Values.mail.domains }}
    ### Domain: {{ .name }}

    #### MX Record
    ```
    {{ .name }}.    MX  10  {{ $.Values.mail.hostname }}.
    ```

    #### SPF Record
    {{- if and $.Values.externalDns.enabled $.Values.externalDns.autoManageDnsRecords }}
    {{- if $ipDetection }}
    ```
    {{ .name }}.    TXT  "v=spf1 ip4:<DETECTED-IP> a:{{ $.Values.mail.hostname }} ~all"
    ```
    *Note: The <DETECTED-IP> will be automatically replaced with the detected external IP when DNS management is enabled.*

    To get the detected IP and generated SPF record:
    ```bash
    kubectl get configmap {{ include "mail-relay.fullname" $ }}-dns-{{ .name | replace "." "-" }} -o jsonpath='{.data.spf-record}'
    ```
    {{- else }}
    {{- /* Build static SPF with all configured external IPs */ -}}
    {{- $spfIps := list -}}
    {{- range $externalIps }}
    {{- $spfIps = append $spfIps (printf "ip4:%s" .) -}}
    {{- end }}
    ```
    {{ .name }}.    TXT  "{{ printf "v=spf1 %s a:%s ~all" (join " " $spfIps) $.Values.mail.hostname }}"
    ```
    *Note: Static external IPs are configured; CronJob is disabled and these IPs are used.*
    {{- end }}
    {{- else }}
    ```
    {{ .name }}.    TXT  "v=spf1 a:{{ $.Values.mail.hostname }} ~all"
    ```
    *Note: This uses hostname-based SPF. For IP-based SPF, replace with your server's external IP:*
    ```
    {{ .name }}.    TXT  "v=spf1 ip4:<YOUR-EXTERNAL-IP> a:{{ $.Values.mail.hostname }} ~all"
    ```
    {{- end }}

    #### DMARC Record (Optional but Recommended)
    ```
    _dmarc.{{ .name }}.    TXT  "v=DMARC1; p=none; rua=mailto:postmaster@{{ .name }}"
    ```

    #### DKIM Record
    The DKIM record will be generated after deployment. Retrieve it using:
    ```bash
    kubectl exec -n {{ $.Release.Namespace }} deployment/{{ include "mail-relay.fullname" $ }}-mail-relay -- \
      cat /data/dkim-keys/{{ .name }}.txt
    ```

    Then add a TXT record:
    ```
    {{ .dkimSelector | default "mail" }}._domainkey.{{ .name }}.    TXT  "<DKIM-PUBLIC-KEY>"
    ```

    ---
    {{- end }}

    ## Testing Commands

    After configuring DNS records, test them:

    ```bash
    # Test A record
    dig A {{ .Values.mail.hostname }}

    {{- range .Values.mail.domains }}
    # Test MX record for {{ .name }}
    dig MX {{ .name }}

    # Test SPF record for {{ .name }}
    dig TXT {{ .name }} | grep spf

    # Test DKIM record for {{ .name }}
    dig TXT {{ .dkimSelector | default "mail" }}._domainkey.{{ .name }}

    # Test DMARC record for {{ .name }}
    dig TXT _dmarc.{{ .name }}
    {{- end }}
    ```

    ## Online Testing Tools

    - MXToolbox: https://mxtoolbox.com/
    - DKIM Validator: https://dkimvalidator.com/
    - SPF Record Checker: https://www.spfwizard.net/

  get-dns-records-with-ip.sh: |
    #!/bin/bash
    # Script to retrieve DNS records with detected external IP

    NAMESPACE="{{ .Release.Namespace }}"
    DEPLOYMENT="{{ include "mail-relay.fullname" . }}"

    echo "Retrieving DNS records with detected external IP..."
    echo "Namespace: $NAMESPACE"
    echo

    {{- if and .Values.externalDns.enabled .Values.externalDns.autoManageDnsRecords }}
    {{- if $ipDetection }}
    # Get detected external IP
    EXTERNAL_IP=""
    if kubectl get pod -n "$NAMESPACE" -l app.kubernetes.io/name={{ include "mail-relay.name" . }} -o name | head -1 | xargs -I {} kubectl exec -n "$NAMESPACE" {} -- test -f /shared/external-ip 2>/dev/null; then
      EXTERNAL_IP=$(kubectl get pod -n "$NAMESPACE" -l app.kubernetes.io/name={{ include "mail-relay.name" . }} -o name | head -1 | xargs -I {} kubectl exec -n "$NAMESPACE" {} -- cat /shared/external-ip 2>/dev/null)
    fi

    if [ -z "$EXTERNAL_IP" ] || [ "$EXTERNAL_IP" = "unknown" ]; then
      echo "‚ö†Ô∏è  External IP not detected or not available"
      echo "Using hostname-based SPF records instead"
      echo
    else
      echo "üåê Detected External IP: $EXTERNAL_IP"
      echo
    fi
    {{- else }}
    # Use statically configured external IPs
    echo "üåê Configured External IPs:"
    {{- range $externalIps }}
    echo " - {{ . }}"
    {{- end }}
    echo
    {{- end }}

    echo "DNS Records to create:"
    echo "================================="

    {{- range .Values.mail.domains }}
    echo
    echo "üìß Domain: {{ .name }}"
    echo "----------------------------------------"

    # Try to get from DNSEndpoint first
    if kubectl get dnsendpoint {{ $.Release.Name }}-dns -n "$NAMESPACE" >/dev/null 2>&1; then
      echo "‚úÖ Auto-generated DNS records available in DNSEndpoint:"
      echo
      A_TARGETS=$(kubectl get dnsendpoint {{ $.Release.Name }}-dns -n "$NAMESPACE" -o jsonpath='{.spec.endpoints[0].targets[*]}' 2>/dev/null)
      echo "A Record(s):"
      for ip in $A_TARGETS; do
        echo "  {{ $.Values.mail.hostname }}. A $ip"
      done
      echo
      echo "MX Record:"
      echo "  {{ .name }}. MX 10 {{ $.Values.mail.hostname }}."
      echo
      echo "SPF Record:"
      {{- if $ipDetection }}
      # Single detected IP
      CURRENT_IP=$(echo "$A_TARGETS" | awk '{print $1}')
      echo "  {{ .name }}. TXT \"v=spf1 ip4:$CURRENT_IP a:{{ $.Values.mail.hostname }} ~all\""
      {{- else }}
      # Multiple static IPs
      SPF_IPS=""
      for ip in $A_TARGETS; do
        SPF_IPS="$SPF_IPS ip4:$ip"
      done
      SPF_IPS=$(echo "$SPF_IPS" | sed -E 's/^ +//')
      echo "  {{ .name }}. TXT \"v=spf1 $SPF_IPS a:{{ $.Values.mail.hostname }} ~all\""
      {{- end }}
      echo
      echo "DMARC Record:"
      echo "  _dmarc.{{ .name }}. TXT \"v=DMARC1; p=none; rua=mailto:postmaster@{{ .name }}\""
      echo
      echo "DKIM Record:"
      echo "  {{ .dkimSelector | default "mail" }}._domainkey.{{ .name }}. TXT \"<DKIM-PUBLIC-KEY>\""
    else
      echo "üìù Manual DNS records (ConfigMap not found):"
      echo
      {{- if $ipDetection }}
      if [ -n "$EXTERNAL_IP" ] && [ "$EXTERNAL_IP" != "unknown" ]; then
        echo "A Record: {{ $.Values.mail.hostname }}. A $EXTERNAL_IP"
        echo "MX Record: {{ .name }}. MX 10 {{ $.Values.mail.hostname }}."
        echo "SPF Record: {{ .name }}. TXT \"v=spf1 ip4:$EXTERNAL_IP a:{{ $.Values.mail.hostname }} ~all\""
        echo "DMARC Record: _dmarc.{{ .name }}. TXT \"v=DMARC1; p=none; rua=mailto:postmaster@{{ .name }}\""
      else
        echo "A Record: {{ $.Values.mail.hostname }}. A <YOUR-EXTERNAL-IP>"
        echo "MX Record: {{ .name }}. MX 10 {{ $.Values.mail.hostname }}."
        echo "SPF Record: {{ .name }}. TXT \"v=spf1 a:{{ $.Values.mail.hostname }} ~all\""
        echo "DMARC Record: _dmarc.{{ .name }}. TXT \"v=DMARC1; p=none; rua=mailto:postmaster@{{ .name }}\""
      fi
      {{- else }}
      # Static configured IPs
      {{- range $externalIps }}
      echo "A Record: {{ $.Values.mail.hostname }}. A {{ . }}"
      {{- end }}
      echo "MX Record: {{ .name }}. MX 10 {{ $.Values.mail.hostname }}."
      echo "SPF Record: {{ .name }}. TXT \"v=spf1{{- range $i, $ip := $externalIps }} ip4:{{ $ip }}{{- end }} a:{{ $.Values.mail.hostname }} ~all\""
      echo "DMARC Record: _dmarc.{{ .name }}. TXT \"v=DMARC1; p=none; rua=mailto:postmaster@{{ .name }}\""
      {{- end }}
    fi
    echo
    echo "----------------------------------------"
    {{- end }}

    {{- else }}
    echo "üîß Auto DNS management is disabled"
    echo "Using static hostname-based records"
    echo
    echo "DNS Records to create:"
    echo "================================="

    {{- range .Values.mail.domains }}
    echo
    echo "üìß Domain: {{ .name }}"
    echo "----------------------------------------"
    echo "A Record: {{ $.Values.mail.hostname }}. A <YOUR-EXTERNAL-IP>"
    echo "MX Record: {{ .name }}. MX 10 {{ $.Values.mail.hostname }}."
    echo "SPF Record: {{ .name }}. TXT \"v=spf1 a:{{ $.Values.mail.hostname }} ~all\""
    echo "DMARC Record: _dmarc.{{ .name }}. TXT \"v=DMARC1; p=none; rua=mailto:postmaster@{{ .name }}\""
    echo "----------------------------------------"
    {{- end }}
    {{- end }}

    echo
    echo "üß™ After creating DNS records, test them with:"
    {{- range .Values.mail.domains }}
    echo "  dig A {{ $.Values.mail.hostname }}"
    echo "  dig MX {{ .name }}"
    echo "  dig TXT {{ .name }}"
    echo "  dig TXT _dmarc.{{ .name }}"
    {{- end }}

  get-dkim-records.sh: |
    #!/bin/bash
    # Script to retrieve DKIM records from secrets

    NAMESPACE="{{ .Release.Namespace }}"
    RELEASE_NAME="{{ .Release.Name }}"

    echo "Retrieving DKIM records from secrets..."
    echo "Namespace: $NAMESPACE"
    echo "Release: $RELEASE_NAME"
    echo

    {{- range .Values.mail.domains }}
    SECRET_NAME="{{ include "mail-relay.fullname" $ }}-dkim-{{ .name | replace "." "-" }}"
    echo
    echo "Domain: {{ .name }}"
    echo "Selector: {{ .dkimSelector | default "mail" }}"
    echo "Secret: $SECRET_NAME"

    if kubectl get secret "$SECRET_NAME" -n "$NAMESPACE" >/dev/null 2>&1; then
      DKIM_RECORD=$(kubectl get secret "$SECRET_NAME" -n "$NAMESPACE" -o jsonpath='{.data.dns\.record}' 2>/dev/null | base64 -d 2>/dev/null || echo "")
      if [ -n "$DKIM_RECORD" ]; then
        echo "DNS Record:"
        echo "{{ .dkimSelector | default "mail" }}._domainkey.{{ .name }} IN TXT \"$DKIM_RECORD\""
        echo
        echo "Formatted for DNS provider:"
        echo "Name: {{ .dkimSelector | default "mail" }}._domainkey.{{ .name }}"
        echo "Type: TXT"
        echo "Value: $DKIM_RECORD"
      else
        echo "‚ùå DKIM record not found in secret"
      fi
    else
      echo "‚ùå DKIM secret not found: $SECRET_NAME"
    fi
    echo "================================="
    {{- end }}

    echo
    echo "üí° To use these records:"
    echo "1. Copy the TXT record value to your DNS provider"
    echo "2. Create a TXT record with the specified Name and Value"
    echo "3. Wait for DNS propagation (usually 5-15 minutes)"
    echo "4. Test DKIM with: https://dkimvalidator.com/"

  test-smtp.sh: |
    #!/bin/bash
    # Script to test SMTP connectivity

    NAMESPACE="{{ .Release.Namespace }}"
    SERVICE="{{ include "mail-relay.fullname" . }}-mail-relay"

    echo "Testing SMTP connectivity..."
    echo "Service: $SERVICE.$NAMESPACE.svc.cluster.local"
    echo

    # Test from within cluster
    kubectl run smtp-test --rm -i --restart=Never --image=busybox -- sh -c "
      echo 'Testing SMTP port {{ .Values.service.ports.smtp.port }}...'
      timeout 10 nc -zv $SERVICE.$NAMESPACE.svc.cluster.local {{ .Values.service.ports.smtp.port }}
    " 2>/dev/null

    echo
    echo "For interactive SMTP testing:"
    echo "kubectl run --rm -i --tty debug --image=busybox --restart=Never -- sh"
    echo "# Then inside the container:"
    echo "telnet $SERVICE.$NAMESPACE.svc.cluster.local 25"

  check-dns-propagation.sh: |
    #!/bin/bash
    # Script to check DNS record propagation

    echo "Checking DNS propagation for {{ .Values.mail.hostname }}..."
    echo "========================================"

    # Check A record
    echo "A Record:"
    dig +short A {{ .Values.mail.hostname }} || echo "A record not found"
    echo

    {{- range .Values.mail.domains }}
    echo "Domain: {{ .name }}"
    echo "----------------"

    # Check MX record
    echo "MX Record:"
    dig +short MX {{ .name }} || echo "MX record not found"
    echo

    # Check SPF record
    echo "SPF Record:"
    dig +short TXT {{ .name }} | grep spf || echo "SPF record not found"
    echo

    # Check DKIM record
    echo "DKIM Record:"
    dig +short TXT {{ .dkimSelector | default "mail" }}._domainkey.{{ .name }} || echo "DKIM record not found"
    echo

    # Check DMARC record
    echo "DMARC Record:"
    dig +short TXT _dmarc.{{ .name }} || echo "DMARC record not found"
    echo
    echo "========================================"
    {{- end }}

  manage-dns.sh: |
    #!/bin/bash
    # Shared DNS management script (mode: job|cron)
    set -o pipefail
    MODE="${1:-job}"
    NAMESPACE="{{ .Release.Namespace }}"
    RELEASE_NAME="{{ .Release.Name }}"
    DNSENDPOINT_NAME="${RELEASE_NAME}-dns"
    TEMPLATE_PATH="/etc/dns-template/dnsendpoint-template.yaml"
    WORK_FILE="/tmp/dnsendpoint.yaml"
    IP_DETECTION={{ if $ipDetection }}true{{ else }}false{{ end }}
    AUTO_DKIM={{ if and .Values.dkim.enabled .Values.dkim.autoGenerate }}true{{ else }}false{{ end }}

    echo "üîÑ DNS Manager (${MODE}) - $(date)"
    echo "IP detection: ${IP_DETECTION} | Auto DKIM: ${AUTO_DKIM}"

    CURRENT_IP=""
    if [ "${IP_DETECTION}" = "true" ]; then
      # Always detect from the primary mail relay pod for consistent egress IP
      echo "üì¶ Locating mail relay pod..."
      POD_NAME=$(kubectl get pods -n "${NAMESPACE}" -l app.kubernetes.io/instance=${RELEASE_NAME},app.kubernetes.io/name={{ include "mail-relay.name" . }} -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || true)
      if [ -z "${POD_NAME}" ]; then
        echo "‚ùå Mail relay pod not found"; [ "${MODE}" = "cron" ] && exit 0 || exit 1
      fi
      echo "üìß Using pod: ${POD_NAME}"
      for service in "https://ifconfig.me/ip" "https://icanhazip.com" "https://ipv4.icanhazip.com"; do
        echo "üåê Trying $service ..."
        if IP=$(kubectl exec -n "${NAMESPACE}" "${POD_NAME}" -- curl -s --connect-timeout 10 --max-time 30 "$service" 2>/dev/null); then
          if echo "$IP" | grep -E '^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$' >/dev/null; then
            CURRENT_IP="$IP"; echo "‚úÖ Detected outbound IP: ${CURRENT_IP}"; break
          fi
        fi
      done
      if [ -z "${CURRENT_IP}" ]; then
        echo "‚ùå Failed to detect external IP"; [ "${MODE}" = "cron" ] && exit 0 || exit 1
      fi
    else
      # Static external IP mode
      EXTERNAL_IPS=( {{- range $externalIps }} "{{ . }}"{{- end }} )
      if [ ${#EXTERNAL_IPS[@]} -eq 0 ]; then
        echo "‚ùå No external IPs configured"; exit 1
      fi
      CURRENT_IP="${EXTERNAL_IPS[0]}"
      echo "Using configured IPs: ${EXTERNAL_IPS[*]} (primary: ${CURRENT_IP})"
    fi

    RECREATE_ENDPOINT=false
    if [ "${MODE}" = "cron" ]; then
      if kubectl get dnsendpoint "${DNSENDPOINT_NAME}" -n "${NAMESPACE}" >/dev/null 2>&1; then
        STORED_IP=$(kubectl get dnsendpoint "${DNSENDPOINT_NAME}" -n "${NAMESPACE}" -o jsonpath='{.spec.endpoints[0].targets[0]}' 2>/dev/null || true)
        echo "üìä Current outbound IP: ${CURRENT_IP}"
        echo "üìä Stored DNS IP: ${STORED_IP}"
        if [ "${CURRENT_IP}" != "${STORED_IP}" ]; then
          echo "üìù IP changed -> updating DNSEndpoint"; kubectl delete dnsendpoint "${DNSENDPOINT_NAME}" -n "${NAMESPACE}" || true; RECREATE_ENDPOINT=true
        else
          echo "‚úÖ IP unchanged; no update needed"; RECREATE_ENDPOINT=false
        fi
      else
        echo "üÜï DNSEndpoint missing -> will create"; RECREATE_ENDPOINT=true
      fi
    else
      # Job always (re)applies to ensure resource exists
      RECREATE_ENDPOINT=true
    fi

    if [ "${RECREATE_ENDPOINT}" != "true" ]; then
      echo "üéâ Done (no changes)"; exit 0
    fi

    cp "${TEMPLATE_PATH}" "${WORK_FILE}" || { echo "‚ùå Missing template at ${TEMPLATE_PATH}"; exit 1; }

    if [ "${IP_DETECTION}" = "true" ]; then
      sed -i "s/\${CURRENT_IP}/${CURRENT_IP}/g" "${WORK_FILE}"
    else
      # Build JSON array for A targets
      A_JSON="["; for i in "${!EXTERNAL_IPS[@]}"; do
        [ "$i" -gt 0 ] && A_JSON+=","; A_JSON+="\"${EXTERNAL_IPS[$i]}\""; done; A_JSON+="]"
      SPF_IPS=""; for ip in "${EXTERNAL_IPS[@]}"; do SPF_IPS+=" ip4:${ip}"; done; SPF_IPS="${SPF_IPS# }"

      # Use a unique placeholder and proper escaping for JSON array replacement
      sed -i 's/targets: \["\${CURRENT_IP}"\]/targets: REPLACE_A_TARGETS_PLACEHOLDER/' "${WORK_FILE}"
      # Escape the A_JSON for safe sed replacement
      A_JSON_ESCAPED=$(printf '%s\n' "$A_JSON" | sed 's/[[\.*^$()+?{|]/\\&/g')
      sed -i "s/REPLACE_A_TARGETS_PLACEHOLDER/${A_JSON_ESCAPED}/" "${WORK_FILE}"

      # Replace SPF IPs with proper escaping
      SPF_IPS_ESCAPED=$(printf '%s\n' "$SPF_IPS" | sed 's/[[\.*^$()+?{|]/\\&/g')
      sed -i "s/ip4:\${CURRENT_IP}/${SPF_IPS_ESCAPED}/g" "${WORK_FILE}"
    fi

    if [ "${AUTO_DKIM}" = "true" ]; then
      echo "üîê Processing DKIM records from secrets..."
    {{- range $index, $domain := .Values.mail.domains }}
      DKIM_RECORD_{{ $index }}=""
      SECRET_NAME="{{ include "mail-relay.fullname" $ }}-dkim-{{ $domain.name | replace "." "-" }}"

      # Try to get DKIM record from secret
      if kubectl get secret "$SECRET_NAME" -n "${NAMESPACE}" >/dev/null 2>&1; then
        DKIM_RECORD_{{ $index }}=$(kubectl get secret "$SECRET_NAME" -n "${NAMESPACE}" -o jsonpath='{.data.dns\.record}' 2>/dev/null | base64 -d 2>/dev/null || true)
      fi

      if [ -n "${DKIM_RECORD_{{ $index }}}" ]; then
        echo "  ‚úÖ DKIM {{ $domain.name }}: ${DKIM_RECORD_{{ $index }}:0:50}..."
        # Escape special characters for sed
        DKIM_ESCAPED=$(printf '%s\n' "${DKIM_RECORD_{{ $index }}}" | sed 's/[[\.*^$()+?{|]/\\&/g')
        sed -i "s|\${DKIM_RECORD_{{ $index }}}|${DKIM_ESCAPED}|g" "${WORK_FILE}"
      else
        echo "  ‚ö†Ô∏è  DKIM secret not found or empty for {{ $domain.name }}"
        # Remove the placeholder line entirely if no DKIM record
        sed -i '/\${DKIM_RECORD_{{ $index }}}/d' "${WORK_FILE}"
      fi
    {{- end }}
    fi

    echo "Generated DNSEndpoint manifest:"; cat "${WORK_FILE}"; echo
    echo "Applying DNSEndpoint..."
    if kubectl apply -f "${WORK_FILE}"; then
      echo "‚úÖ DNSEndpoint applied"
    else
      echo "‚ùå Failed to apply DNSEndpoint"; exit 1
    fi
    rm -f "${WORK_FILE}" 2>/dev/null || true
    echo "üéâ DNS management completed - $(date)"

{{- end }}
