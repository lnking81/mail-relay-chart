apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "mail-relay.fullname" . }}-entrypoint
  labels:
    {{- include "mail-relay.labels" . | nindent 4 }}
data:
  entrypoint.sh: |
    #!/bin/bash
    # Unified entrypoint: combines safety, constants, leveled logging, portable domain parsing, modular helpers
    set -Eeuo pipefail
    umask 027
    IFS=$'\n\t'

    # ---------------------- Constants ----------------------
    readonly POSTFIX_SPOOL_DIR="/var/spool/postfix"
    readonly PERSISTENT_SPOOL_DIR="/data/postfix-spool"
    readonly DKIM_KEYS_DIR="/data/dkim-keys"
    readonly LOCAL_DKIM_KEYS_DIR="/etc/opendkim/keys"
    readonly SUPERVISOR_LOG_DIR="/var/log/supervisor"
    readonly SUPERVISOR_CONF="/etc/supervisor/supervisord.conf"
    readonly QUEUE_DIRS=(active bounce corrupt defer deferred flush hold incoming saved trace)

    # ---------------------- Logging ----------------------
    timestamp() { date '+%Y-%m-%dT%H:%M:%S%z'; }
    _log() { # level message...
        local level="$1"; shift
        printf '%s %-5s %s\n' "$(timestamp)" "$level" "$*"
    }
    info() { _log INFO "$@"; }
    warn() { _log WARN "$@"; }
    error() { _log ERROR "$@" >&2; }
    fail() { error "$@"; exit 1; }

    trap 'warn "Termination signal received; shutting down"' TERM INT

    info "=== Mail Relay Container Starting ==="

    # ---------------------- Generic Helpers ----------------------
    ensure_dir() { # path owner group mode
        local p="$1" o="$2" g="$3" m="$4"
        mkdir -p "$p"
        chown "$o:$g" "$p"
        chmod "$m" "$p"
        chmod u-s,g-s "$p" 2>/dev/null || true
    }

    safe_copy() { # src dest mode owner:group(optional)
        local src="$1" dest="$2" mode="$3" own="$4"
        [ -f "$src" ] || fail "Missing required file: $src"
        install -m "$mode" "$src" "$dest"
        [ -n "$own" ] && chown "$own" "$dest"
    }

    validate_environment() {
        info "Validating runtime environment"
        id postfix >/dev/null 2>&1 || fail "postfix user missing"
        getent group postdrop >/dev/null 2>&1 || fail "postdrop group missing"
        info "Environment validation passed"
    }

    parse_domains() {
        DKIM_DOMAINS_ARR=()
        local raw="${DKIM_DOMAINS:-}" tokens
        [ -z "$raw" ] && return 0
        # Normalize to one per line, trim, filter empties
        mapfile -t tokens < <(echo "$raw" | tr ',' '\n' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' | grep -Ev '^[[:space:]]*$' || true)
        local t
        for t in "${tokens[@]}"; do
            if [[ "$t" =~ ^[A-Za-z0-9.-]+$ ]]; then
                DKIM_DOMAINS_ARR+=("$t")
            else
                warn "Skipping invalid domain token: $t"
            fi
        done
    }

    # ---------------------- Postfix Config ----------------------
    copy_postfix_config() {
        info "Copying Postfix configuration from configmap"
        safe_copy /tmp/postfix-config/main.cf /etc/postfix/main.cf 644 root:root
        safe_copy /tmp/postfix-config/master.cf /etc/postfix/master.cf 644 root:root
        if [ -f /tmp/postfix-config/header_checks ]; then
            info "Installing header_checks"
            safe_copy /tmp/postfix-config/header_checks /etc/postfix/header_checks 644 root:root
            postmap /etc/postfix/header_checks || fail "postmap header_checks failed"
        fi
    }

    prepare_sasl() {
        [ "${RELAY_CREDENTIALS_ENABLED:-false}" = "true" ] || return 0
        if [ -f /tmp/postfix-config/sasl_passwd ]; then
            info "Configuring SASL relay credentials"
            safe_copy /tmp/postfix-config/sasl_passwd /etc/postfix/sasl_passwd 600 root:root
            postmap /etc/postfix/sasl_passwd || fail "postmap sasl_passwd failed"
            chmod 600 /etc/postfix/sasl_passwd*
        else
            warn "RELAY_CREDENTIALS_ENABLED=true but sasl_passwd not found"
        fi
    }

    prepare_sender_access() {
        [ "${SENDER_ACCESS_ENABLED:-false}" = "true" ] || return 0
        if [ -f /tmp/postfix-config/sender_access ]; then
            info "Installing sender_access map"
            safe_copy /tmp/postfix-config/sender_access /etc/postfix/sender_access 644 root:root
            postmap /etc/postfix/sender_access || fail "postmap sender_access failed"
        else
            warn "SENDER_ACCESS_ENABLED=true but sender_access file missing"
        fi
    }

    # ---------------------- Postfix Queue Layout ----------------------
    setup_postfix_directories() { # (re)create or repair directory structure
        local spool_dir="$1"
        info "Ensuring Postfix directories under $spool_dir"
        ensure_dir "$spool_dir" postfix postfix 755
        local d
        for d in "${QUEUE_DIRS[@]}"; do
            ensure_dir "$spool_dir/$d" postfix postfix 700
        done
        ensure_dir "$spool_dir/private" postfix postfix 700
        ensure_dir "$spool_dir/public" postfix postdrop 730
        ensure_dir "$spool_dir/maildrop" postfix postdrop 730
        ensure_dir "$spool_dir/pid" root root 755
        chown postfix:postfix "$spool_dir"; chmod 755 "$spool_dir"; chmod u-s,g-s "$spool_dir" 2>/dev/null || true
    }

    verify_postfix_permissions() { # spool_dir
        local spool_dir="$1" errors=0 owner group perms d
        for d in "${QUEUE_DIRS[@]}" private; do
            if [ -d "$spool_dir/$d" ]; then
                owner=$(stat -c '%U' "$spool_dir/$d" 2>/dev/null || echo ?) || true
                group=$(stat -c '%G' "$spool_dir/$d" 2>/dev/null || echo ?) || true
                perms=$(stat -c '%a' "$spool_dir/$d" 2>/dev/null || echo 000) || true
                if [ "$owner:$group:$perms" != "postfix:postfix:700" ]; then
                    warn "Permission mismatch $spool_dir/$d -> $owner:$group $perms (expected postfix:postfix 700)"
                    errors=$((errors+1))
                fi
            fi
        done
        for d in public maildrop; do
            if [ -d "$spool_dir/$d" ]; then
                owner=$(stat -c '%U' "$spool_dir/$d" 2>/dev/null || echo ?) || true
                group=$(stat -c '%G' "$spool_dir/$d" 2>/dev/null || echo ?) || true
                perms=$(stat -c '%a' "$spool_dir/$d" 2>/dev/null || echo 000) || true
                if [ "$owner:$group:$perms" != "postfix:postdrop:730" ]; then
                    warn "Permission mismatch $spool_dir/$d -> $owner:$group $perms (expected postfix:postdrop 730)"
                    errors=$((errors+1))
                fi
            fi
        done
        if [ -d "$spool_dir/pid" ]; then
            owner=$(stat -c '%U' "$spool_dir/pid" 2>/dev/null || echo ?) || true
            group=$(stat -c '%G' "$spool_dir/pid" 2>/dev/null || echo ?) || true
            perms=$(stat -c '%a' "$spool_dir/pid" 2>/dev/null || echo 000) || true
            if [ "$owner:$group:$perms" != "root:root:755" ]; then
                warn "Permission mismatch $spool_dir/pid -> $owner:$group $perms (expected root:root 755)"
                errors=$((errors+1))
            fi
        fi
        if [ $errors -eq 0 ]; then
            info "Postfix permission verification passed"
        else
            warn "Postfix permission verification found $errors issues"
        fi
        return $errors
    }

    init_or_repair_postfix_spool() {
        local persistent="${PERSISTENCE_ENABLED:-false}" target
        if [ "$persistent" = "true" ]; then
            target="$PERSISTENT_SPOOL_DIR"
            ensure_dir "$target" postfix postfix 755
            if [ ! -f "$target/.initialized" ]; then
                info "Initializing persistent Postfix spool structure"
                if [ -d "$POSTFIX_SPOOL_DIR" ] && [ "$(ls -A "$POSTFIX_SPOOL_DIR" 2>/dev/null | wc -l)" -gt 0 ]; then
                    cp -r "$POSTFIX_SPOOL_DIR"/* "$target/" 2>/dev/null || true
                fi
                setup_postfix_directories "$target"
                touch "$target/.initialized"
            else
                info "Repairing existing persistent spool permissions"
                setup_postfix_directories "$target"
            fi
            if [ ! -L "$POSTFIX_SPOOL_DIR" ] || [ "$(readlink -f "$POSTFIX_SPOOL_DIR" || true)" != "$target" ]; then
                rm -rf "$POSTFIX_SPOOL_DIR"
                ln -s "$target" "$POSTFIX_SPOOL_DIR"
            fi
            chown -h postfix:postfix "$POSTFIX_SPOOL_DIR" || true
        else
            target="$POSTFIX_SPOOL_DIR"
            setup_postfix_directories "$target"
        fi
        verify_postfix_permissions "$target" || warn "Some permissions were incorrect (continuing)"
        info "Queue setup complete (persistent=$persistent)"
    }

    # Repair any stray maildrop file ownership/permissions that could cause pickup 'Permission denied'
    repair_maildrop_files() {
        local spool_dir="$1" maildrop_dir="$1/maildrop"
        [ -d "$maildrop_dir" ] || return 0
        # Find files not owned by postfix or with group/other read bits and repair
        local repaired=0
        while IFS= read -r f; do
            [ -z "$f" ] && continue
            chown postfix:postfix "$f" 2>/dev/null || true
            chmod 600 "$f" 2>/dev/null || true
            repaired=$((repaired+1))
        done < <(find "$maildrop_dir" -maxdepth 1 -type f \( ! -user postfix -o -perm /022 \) -print 2>/dev/null || true)
        [ $repaired -gt 0 ] && info "Repaired $repaired maildrop file permission/ownership issues" || true
    }

    # ---------------------- OpenDKIM ----------------------
    # Copy DKIM keys from Kubernetes secrets to OpenDKIM directory
    # Keys are mounted from secrets at /data/dkim-secrets/{domain}/
    # and need to be copied to /etc/opendkim/keys/ for OpenDKIM to use
    sync_dkim_keys_from_secrets() {
        [ "${DKIM_ENABLED:-false}" = "true" ] || return 0
        [ ${#DKIM_DOMAINS_ARR[@]} -gt 0 ] || { warn "DKIM enabled but no domains configured"; return 0; }

        ensure_dir "$LOCAL_DKIM_KEYS_DIR" opendkim opendkim 700

        local domain secret_dir private_key_file dns_record_file
        for domain in "${DKIM_DOMAINS_ARR[@]}"; do
            secret_dir="/data/dkim-secrets/${domain}"

            if [ ! -d "$secret_dir" ]; then
                warn "DKIM secret directory not found for $domain at $secret_dir"
                continue
            fi

            private_key_file="$secret_dir/private.key"
            dns_record_file="$secret_dir/dns.record"

            if [ ! -f "$private_key_file" ]; then
                warn "DKIM private key not found for $domain at $private_key_file"
                continue
            fi

            info "Installing DKIM key for $domain from Kubernetes secret"

            # Copy private key to OpenDKIM directory
            cp "$private_key_file" "$LOCAL_DKIM_KEYS_DIR/${domain}.private"
            chown opendkim:opendkim "$LOCAL_DKIM_KEYS_DIR/${domain}.private"
            chmod 600 "$LOCAL_DKIM_KEYS_DIR/${domain}.private"

            # Copy DNS record if available (for reference/logging)
            if [ -f "$dns_record_file" ]; then
                cp "$dns_record_file" "$LOCAL_DKIM_KEYS_DIR/${domain}.txt"
                chown opendkim:opendkim "$LOCAL_DKIM_KEYS_DIR/${domain}.txt"
                chmod 644 "$LOCAL_DKIM_KEYS_DIR/${domain}.txt"
                info "DKIM DNS record for $domain: $(cat "$dns_record_file")"
            fi

            # Verify OpenDKIM can read the key
            if su -s /bin/bash opendkim -c "[ -r '$LOCAL_DKIM_KEYS_DIR/${domain}.private' ]"; then
                info "✅ OpenDKIM can read key for $domain"
            else
                error "❌ OpenDKIM cannot read key for $domain"
            fi
        done
    }

    prepare_opendkim() {
        [ "${DKIM_ENABLED:-false}" = "true" ] || return 0
        info "Configuring OpenDKIM"
        safe_copy /tmp/opendkim-config/opendkim.conf /etc/opendkim.conf 644 root:root
        safe_copy /tmp/opendkim-config/TrustedHosts /etc/opendkim/TrustedHosts 644 root:root
        safe_copy /tmp/opendkim-config/KeyTable /etc/opendkim/KeyTable 644 root:root
        safe_copy /tmp/opendkim-config/SigningTable /etc/opendkim/SigningTable 644 root:root
        parse_domains
        sync_dkim_keys_from_secrets
        ensure_dir /var/run/opendkim opendkim opendkim 755
        info "OpenDKIM configuration completed"
    }

    # ---------------------- Postfix Config Permissions ----------------------
    secure_postfix_config_dir() {
        info "Securing /etc/postfix"
        chown -R root:root /etc/postfix || true
        find /etc/postfix -type d -exec chmod 755 {} +
        find /etc/postfix -type f -exec chmod 644 {} +
        if [ -f /etc/postfix/sasl_passwd ]; then
            chmod 600 /etc/postfix/sasl_passwd*
            chown root:root /etc/postfix/sasl_passwd*
        fi
    }

    # ---------------------- Final Sanity Checks ----------------------
    final_sanity_checks() {
        info "Performing final sanity checks"
        [ -d "$POSTFIX_SPOOL_DIR" ] || fail "$POSTFIX_SPOOL_DIR missing"
        if [ -L "$POSTFIX_SPOOL_DIR" ]; then
            info "Using persistent spool: $(readlink -f "$POSTFIX_SPOOL_DIR" || echo unknown)"
        else
            info "Using non-persistent spool"
        fi
        info "Sanity checks completed"
    }

    prepare_supervisor() {
        ensure_dir "$SUPERVISOR_LOG_DIR" root root 755
        if [ -f /tmp/supervisor-config/supervisord.conf ]; then
            safe_copy /tmp/supervisor-config/supervisord.conf "$SUPERVISOR_CONF" 644 root:root
        else
            fail "Missing supervisor configuration"
        fi
    }

    # ---------------------- Main Flow ----------------------
    main() {
        validate_environment
        copy_postfix_config
        prepare_sasl
        prepare_sender_access
        prepare_opendkim
        init_or_repair_postfix_spool
        repair_maildrop_files "${PERSISTENCE_ENABLED:-false}" = "true" && repair_maildrop_files "$PERSISTENT_SPOOL_DIR" || repair_maildrop_files "$POSTFIX_SPOOL_DIR" 2>/dev/null || true
        secure_postfix_config_dir
        prepare_supervisor
        final_sanity_checks
        info "Starting supervisord (Postfix & OpenDKIM managed services)"
        exec /usr/bin/supervisord -c "$SUPERVISOR_CONF"
    }

    main "$@"
