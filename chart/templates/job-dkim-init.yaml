{{- if and .Values.dkim.enabled .Values.dkim.autoGenerate }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "mail-relay.fullname" . }}-dkim-init
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "mail-relay.labels" . | nindent 4 }}
    app.kubernetes.io/component: dkim-init
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-weight": "-1"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
spec:
  template:
    metadata:
      labels:
        {{- include "mail-relay.selectorLabels" . | nindent 8 }}
        app.kubernetes.io/component: dkim-init
    spec:
      serviceAccountName: {{ include "mail-relay.serviceAccountName" . }}
      restartPolicy: OnFailure
      containers:
      - name: dkim-init
        image: alpine/k8s:1.28.2
        command:
        - /bin/sh
        - -c
        - |
          set -e
          echo "🔐 DKIM Initialization Job - $(date)"

          # Install required packages (kubectl is already available in alpine/k8s)
          # Install openssl and other tools
          apk add --no-cache openssl curl jq

          {{- range $index, $domain := .Values.mail.domains }}
          {{- if not $domain.dkim }}
          echo "Processing domain: {{ $domain.name }}"
          SECRET_NAME="{{ include "mail-relay.fullname" $ }}-dkim-{{ $domain.name | replace "." "-" }}"
          DOMAIN_NAME="{{ $domain.name }}"
          SELECTOR="{{ $domain.dkimSelector | default "mail" }}"

          # Check if DKIM secret already exists and verify its integrity
          NEED_GENERATION=false
          if kubectl get secret "$SECRET_NAME" >/dev/null 2>&1; then
            echo "  🔍 Found existing secret for $DOMAIN_NAME, verifying integrity..."

            # Check private key
            PRIVATE_KEY=$(kubectl get secret "$SECRET_NAME" -o jsonpath='{.data.private\.key}' 2>/dev/null | base64 -d 2>/dev/null || echo "")
            if [ -z "$PRIVATE_KEY" ] || ! echo "$PRIVATE_KEY" | grep -qE "BEGIN (RSA )?PRIVATE KEY"; then
              echo "  ❌ Private key missing or invalid"
              NEED_GENERATION=true
            fi

            # Check public key
            PUBLIC_KEY_STORED=$(kubectl get secret "$SECRET_NAME" -o jsonpath='{.data.public\.key}' 2>/dev/null | base64 -d 2>/dev/null || echo "")
            if [ -z "$PUBLIC_KEY_STORED" ]; then
              echo "  ❌ Public key missing"
              NEED_GENERATION=true
            fi

            # Check DNS record
            DNS_RECORD=$(kubectl get secret "$SECRET_NAME" -o jsonpath='{.data.dns\.record}' 2>/dev/null | base64 -d 2>/dev/null || echo "")
            if [ -z "$DNS_RECORD" ] || ! echo "$DNS_RECORD" | grep -q "^v=DKIM1"; then
              echo "  ❌ DNS record missing or invalid"
              NEED_GENERATION=true
            fi

            # Check selector
            STORED_SELECTOR=$(kubectl get secret "$SECRET_NAME" -o jsonpath='{.data.selector}' 2>/dev/null | base64 -d 2>/dev/null || echo "")
            if [ -z "$STORED_SELECTOR" ] || [ "$STORED_SELECTOR" != "$SELECTOR" ]; then
              echo "  ❌ Selector missing or changed (expected: $SELECTOR, found: $STORED_SELECTOR)"
              NEED_GENERATION=true
            fi

            # Verify key pair consistency (public key should match private key)
            if [ "$NEED_GENERATION" = "false" ]; then
              echo "  🔑 Verifying key pair consistency..."
              echo "$PRIVATE_KEY" > /tmp/test_private.key
              DERIVED_PUBLIC=$(openssl rsa -in /tmp/test_private.key -pubout -outform DER 2>/dev/null | openssl base64 -A 2>/dev/null || echo "")
              if [ "$DERIVED_PUBLIC" != "$PUBLIC_KEY_STORED" ]; then
                echo "  ❌ Public/private key pair mismatch"
                NEED_GENERATION=true
              fi
              rm -f /tmp/test_private.key
            fi

            if [ "$NEED_GENERATION" = "false" ]; then
              echo "  ✅ DKIM keys are valid and complete for $DOMAIN_NAME"
              continue
            else
              echo "  🧹 Removing invalid/incomplete secret for $DOMAIN_NAME"
              kubectl delete secret "$SECRET_NAME" || true
            fi
          else
            echo "  📝 No existing secret found for $DOMAIN_NAME"
            NEED_GENERATION=true
          fi

          if [ "$NEED_GENERATION" = "true" ]; then
            echo "  🔑 Generating new DKIM keys for $DOMAIN_NAME..."

            # Generate DKIM key pair
            openssl genrsa -out /tmp/dkim_private.key 2048
            openssl rsa -in /tmp/dkim_private.key -pubout -outform DER | openssl base64 -A > /tmp/dkim_public.key

            # Create DNS TXT record content
            PUBLIC_KEY=$(cat /tmp/dkim_public.key)
            DNS_RECORD="v=DKIM1;h=sha256;k=rsa;p=$PUBLIC_KEY"

            # Create secret with all DKIM data
            kubectl create secret generic "$SECRET_NAME" \
              --from-file=private.key=/tmp/dkim_private.key \
              --from-literal=public.key="$PUBLIC_KEY" \
              --from-literal=dns.record="$DNS_RECORD" \
              --from-literal=selector="$SELECTOR"

            # Add labels and annotations
            kubectl label secret "$SECRET_NAME" \
              app.kubernetes.io/name="{{ include "mail-relay.name" $ }}" \
              app.kubernetes.io/instance="{{ $.Release.Name }}" \
              app.kubernetes.io/version="{{ $.Chart.AppVersion }}" \
              app.kubernetes.io/managed-by="Helm" \
              helm.sh/chart="{{ include "mail-relay.chart" $ }}" \
              app.kubernetes.io/component="dkim" \
              mail-relay.io/domain="$DOMAIN_NAME"

            {{- if $.Values.dkim.preserveSecretsOnDelete }}
            kubectl annotate secret "$SECRET_NAME" \
              helm.sh/resource-policy="keep"
            {{- end }}

            echo "  ✅ DKIM keys generated and stored for $DOMAIN_NAME"
            rm -f /tmp/dkim_private.key /tmp/dkim_public.key
          fi
          {{- end }}
          {{- end }}

          echo "🎉 DKIM initialization completed - $(date)"
        env:
        - name: NAMESPACE
          value: {{ .Release.Namespace }}
        volumeMounts: []
      volumes: []
{{- end }}
