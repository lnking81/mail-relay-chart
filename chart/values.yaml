# =============================================================================
# Mail Relay Helm Chart - Default Values
# Haraka-based SMTP relay with DKIM signing and DNS automation
# =============================================================================

# === Container Image ===
image:
  repository: ghcr.io/lnking81/mail-relay-chart
  # Defaults to Chart appVersion if not set
  tag: ""
  pullPolicy: IfNotPresent

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

# === Haraka Configuration ===
haraka:
  # Custom SMTP banner (hides Haraka version for security)
  # Default Haraka shows: "220 hostname ESMTP Haraka/x.x.x ready (UUID)"
  # Set custom greeting to hide software identity
  # Example: "ready" -> "220 hostname ESMTP ready"
  smtpBanner: "ready"

  # Show UUID in banner (default: 6 chars). Set to 0 to hide completely
  bannerUuidChars: 0

  # Maximum message size in bytes (0 = unlimited)
  # Default: 26214400 (25 MB)
  # Examples: 10485760 (10MB), 52428800 (50MB), 104857600 (100MB)
  maxMessageSize: 26214400

  # Additional plugins beyond core (relay, dkim_sign, limit)
  # Example: ["spf", "headers"]
  plugins: []

  # Log level: debug, info, notice, warn, error, crit
  # Use 'info' for production, 'debug' for troubleshooting
  logLevel: info

  # Outbound connection concurrency
  concurrency: 50

  # IP version preference for outbound delivery
  # - "default": Prefer IPv6 when both exist at same MX priority
  # - "v4": Try IPv4 first, then IPv6
  # - "v6": Try IPv6 first, then IPv4
  inetPrefer: "v4"

  # Queue directory inside container
  queueDir: /data/queue

  # === Strip Internal Headers ===
  # Remove internal/sensitive headers from outgoing mail
  # Prevents exposure of internal infrastructure (pod names, internal IPs)
  stripHeaders:
    # Enable header stripping
    enabled: true

    # Remove ALL Received headers (maximum privacy)
    # Use when you don't want ANY routing history exposed
    stripAllReceived: false

    # Remove only Received headers with internal information:
    # - RFC1918 IPs (10.x, 172.16-31.x, 192.168.x)
    # - Loopback/link-local addresses
    # - Kubernetes pod/service names
    # - .local, .internal, .cluster.local domains
    stripInternalReceived: true

    # Additional headers to always strip (beyond Received)
    # Common examples: X-Originating-IP, X-Mailer, User-Agent
    headers: []
    # Example:
    # headers:
    #   - X-Originating-IP
    #   - X-Mailer

    # Additional regex patterns to detect internal hostnames
    # Built-in patterns detect Kubernetes pod names, .local, .cluster.local, etc.
    # Add custom patterns for your infrastructure
    internalHostnamePatterns: []
    # Example:
    # internalHostnamePatterns:
    #   - "\\.my-internal\\.domain$"
    #   - "^internal-host-"

  # HAProxy PROXY Protocol v1/v2 support
  # Enables preservation of real client IP through load balancers
  #
  # NOTE: proxyProtocol is now configured per-service in services[] array.
  # This section only configures WHICH source IPs trigger PROXY parsing.
  proxyProtocol:
    # Auto-detect trusted proxies from LoadBalancer Service status
    # When enabled, IPs from .status.loadBalancer.ingress[] are automatically
    # added to trustedProxies at container startup
    #
    # Works with: Hetzner Cloud, AWS NLB, GCP, Azure, MetalLB, etc.
    # Requires: serviceAccount with "get services" permission (auto-configured)
    #
    # Example: If LoadBalancer has ingress IPs [142.132.243.70, 10.128.0.5],
    # both will be trusted for PROXY protocol
    autoDetect: false

    # Trusted proxy sources (IPs or CIDRs)
    # Only connections from these sources will have PROXY headers parsed
    # Combined with auto-detected IPs when autoDetect: true
    #
    # Should contain your LoadBalancer's backend/node IPs, NOT pod CIDRs!
    # Examples:
    #   - "10.0.0.0/8"        # If your LB nodes are in this range
    #   - "192.168.1.100"     # Specific load balancer IP
    #
    # If empty and services have proxyProtocol: true, accepts from any source
    # (not recommended - internal connections will fail)
    trustedProxies: []

# === Mail Settings ===
mail:
  # FQDN used in SMTP banner and HELO/EHLO
  hostname: mail.example.com

  # Domains to handle
  # Each domain can have its own DKIM selector
  domains:
    - name: example.com
      dkimSelector: mail

  # Upstream relay configuration (optional)
  # If disabled, mail is delivered directly to recipient MX
  relay:
    enabled: false
    host: ""
    port: 587
    tls: true
    auth:
      enabled: false
      username: ""
      password: ""
      # Use existing secret instead of inline credentials
      # Secret must have keys: username, password
      existingSecret: ""

  # Networks allowed to relay through this server
  # These IPs/CIDRs can send mail without authentication
  trustedNetworks:
    - "10.0.0.0/8"
    - "172.16.0.0/12"
    - "192.168.0.0/16"

  # === Sender Validation ===
  # Restrict which domains/addresses can send through this relay
  senderValidation:
    # Enable sender domain whitelist
    # When true, only allowed senders can use MAIL FROM
    enabled: true
    # Check From header matches MAIL FROM domain
    # Prevents From header spoofing
    checkFromHeader: true

    # Allowed senders whitelist
    # STRICT MODE: If specified, ONLY these senders are allowed
    #              (mail.domains is NOT automatically included)
    # If empty: all addresses in mail.domains are allowed
    # Supports: email addresses, domains, regex patterns
    # Examples:
    #   - "service@partner.com"       # Specific address
    #   - "partner.com"               # Entire domain
    #   - "/.*@notifications\\./"     # Regex (must start with /)
    allowedFrom: []

    # Forbidden senders blacklist (takes priority over whitelist)
    # Prevents internal addresses from being spoofed by external software
    # Use for: protecting real user addresses from being used as MAIL FROM
    # Examples:
    #   - "ceo@example.com"           # Block specific high-value address
    #   - "hr@example.com"
    #   - "/support\\+.*@/"           # Block support+tag@ addresses
    forbiddenFrom: []

# === Delivery Rate Limiting ===
# Control outbound delivery speed per domain (prevents Gmail/Yahoo throttling)
rateLimit:
  # Enable outbound rate limiting
  enabled: false

  # Global limits (applied to all domains unless overridden)
  global:
    # Max concurrent outbound connections total
    maxConnections: 100
    # Max messages per connection before reconnect
    maxPerConnection: 50
    # Delay between messages in milliseconds (0 = no delay)
    delayBetweenMessages: 0

  # Per-domain limits for major providers (prevents reputation damage)
  # Format: rate is "count/interval" where interval is s/m/h/d
  # Example: "1/20s" = 1 message every 20 seconds
  domains:
    # Gmail - very strict, needs slow warmup
    gmail.com:
      enabled: false
      # Max concurrent connections to Gmail
      maxConnections: 1
      # Messages per connection
      maxPerConnection: 3
      # Rate limit: messages per interval
      rate: "1/20s"
      # Delay between messages (ms)
      delayMs: 15000

    # Google Workspace (same as Gmail)
    googlemail.com:
      enabled: false
      maxConnections: 1
      maxPerConnection: 3
      rate: "1/20s"
      delayMs: 15000

    # Microsoft (Outlook, Hotmail, Live)
    outlook.com:
      enabled: false
      maxConnections: 2
      maxPerConnection: 5
      rate: "1/10s"
      delayMs: 10000

    hotmail.com:
      enabled: false
      maxConnections: 2
      maxPerConnection: 5
      rate: "1/10s"
      delayMs: 10000

    live.com:
      enabled: false
      maxConnections: 2
      maxPerConnection: 5
      rate: "1/10s"
      delayMs: 10000

    # Yahoo
    yahoo.com:
      enabled: false
      maxConnections: 2
      maxPerConnection: 10
      rate: "1/10s"
      delayMs: 10000

  # Custom domain limits (add your own)
  # customDomains:
  #   example.com:
  #     maxConnections: 5
  #     rate: "10/1m"
  customDomains: {}

# === Adaptive Rate Limiting (Dynamic) ===
# Automatically adjusts delivery speed based on server responses
# When receiving 421/rate limit errors - slows down (backoff)
# When deliveries succeed - speeds up (recovery)
#
# CIRCUIT BREAKER:
# When consecutive rate-limit failures reach threshold, the "circuit opens":
# - All sends to this provider are paused for circuitBreakerDuration
# - No connection attempts are made during this period
# - This gives the provider time to "cool down"
# - After duration expires, circuit closes and normal operation resumes
adaptiveRate:
  # Enable adaptive rate limiting
  enabled: false

  # Port for metrics endpoint (separate from main Haraka metrics)
  metricsPort: 8093

  # Default settings for all domains
  defaults:
    # Minimum delay between messages (ms) - won't go faster than this
    minDelay: 1000
    # Maximum delay between messages (ms) - won't go slower than this
    maxDelay: 300000 # 5 minutes
    # Initial delay when starting (ms)
    initialDelay: 5000
    # Multiply delay by this on failure (1.5 = +50%)
    backoffMultiplier: 1.5
    # Multiply delay by this on success (0.9 = -10%)
    recoveryRate: 0.9
    # Consecutive successes needed before reducing delay
    successThreshold: 5
    # Circuit breaker: rate-limit failures before circuit opens
    circuitBreakerThreshold: 5
    # Circuit breaker: duration to pause all sends (ms)
    circuitBreakerDuration: 600000 # 10 minutes

  # Per-domain configuration
  # Only domains listed here will have adaptive rate limiting
  domains:
    # Gmail - very strict, use conservative settings
    gmail.com:
      enabled: false
      minDelay: 15000 # 15 seconds minimum
      maxDelay: 300000 # 5 minutes maximum
      initialDelay: 20000 # Start at 20 seconds
      backoffMultiplier: 2.0 # Double delay on failure
      recoveryRate: 0.95 # Slow recovery
      successThreshold: 10 # Need 10 successes to speed up
      circuitBreakerThreshold: 5
      circuitBreakerDuration: 900000 # 15 minutes for Gmail

    # Google Workspace (same infrastructure as Gmail)
    googlemail.com:
      enabled: false
      minDelay: 15000
      maxDelay: 300000
      initialDelay: 20000
      backoffMultiplier: 2.0
      recoveryRate: 0.95
      successThreshold: 10
      circuitBreakerThreshold: 5
      circuitBreakerDuration: 900000

    # Microsoft (Outlook, Hotmail, Live)
    outlook.com:
      enabled: false
      minDelay: 10000
      maxDelay: 300000
      initialDelay: 15000
      backoffMultiplier: 1.5
      recoveryRate: 0.9
      successThreshold: 5
      circuitBreakerThreshold: 5
      circuitBreakerDuration: 900000 # 15 minutes for Microsoft

    hotmail.com:
      enabled: false
      minDelay: 10000
      maxDelay: 300000
      initialDelay: 15000
      circuitBreakerDuration: 900000

    live.com:
      enabled: false
      minDelay: 10000
      maxDelay: 300000
      initialDelay: 15000
      circuitBreakerDuration: 900000

    # Yahoo
    yahoo.com:
      enabled: false
      minDelay: 10000
      maxDelay: 300000
      initialDelay: 15000
      circuitBreakerThreshold: 5
      circuitBreakerDuration: 600000

  # Custom domains (add your own)
  # customDomains:
  #   corporate.com:
  #     enabled: true
  #     minDelay: 5000
  #     initialDelay: 10000
  #     circuitBreakerThreshold: 3
  #     circuitBreakerDuration: 300000
  customDomains: {}

  # State persistence (requires persistence.enabled=true)
  # Saves state to disk so circuit breakers survive pod restarts
  persistence:
    # Enable state persistence
    enabled: true
    # File path for state (relative to /data volume)
    stateFile: /data/adaptive-rate-state.json
    # How often to save state (ms) - also saves immediately on circuit breaker trip
    saveInterval: 300000 # 5 minutes
    # Maximum age of state file to restore (ms) - older files ignored
    maxAge: 3600000 # 1 hour

# === DKIM Configuration ===
dkim:
  # Enable DKIM signing
  enabled: true

  # RSA key size for auto-generated keys
  keySize: 2048

  # Keys are auto-generated via init container and stored in Secrets
  # To use pre-existing keys, create secrets manually with format:
  #   {release}-dkim-{domain-with-dashes}
  # containing: private.key, public.key, dns.record, selector

# === DNS Automation ===
dns:
  # Enable DNS record management
  enabled: false

  # DNS Provider: "external-dns" | "cloudflare"
  # - external-dns: Creates DNSEndpoint CRD for external-dns controller
  # - cloudflare: Direct Cloudflare API integration (recommended for TXT records)
  provider: external-dns

  # Ownership tracking for managed DNS records
  # Records are marked with TXT records to prevent modifying records
  # created by other instances or manually
  ownership:
    # Unique identifier for this instance
    # Default: "{namespace}/{release-name}"
    # Set custom value when multiple releases share zones
    ownerId: ""

    # TXT record prefix for ownership markers
    # Creates records like: _mail-relay-owner.example.com
    txtPrefix: "mail-relay-owner"

  # IP Detection settings
  ip:
    # Auto-detect IP from Service (LoadBalancer or NodePort)
    fromService: true

    # Detect outbound NAT IP via external API
    # Required for SPF when outbound IP differs from incoming
    detectOutbound: true

    # For NodePort: how to get node external IP
    # Options: "api" (from node ExternalIP), "externalApi" (curl), "static"
    nodeIpSource: "api"

    # External APIs for IP detection
    externalApis:
      - https://ifconfig.me/ip
      - https://icanhazip.com
      - https://api.ipify.org

    # Static IPs (all will be added to SPF, first used for A record)
    # If set, disables auto-detection
    static: []
    # Example for dual-IP setup:
    # static:
    #   - 203.0.113.50   # Incoming (A record)
    #   - 198.51.100.10  # Outgoing (SPF only)

  # Cloudflare DNS provider settings (when provider: cloudflare)
  cloudflare:
    # API Token with DNS:Edit permissions for zones
    # Token permissions: Zone:DNS:Edit, Zone:Zone:Read
    # Create at: https://dash.cloudflare.com/profile/api-tokens
    apiToken: ""

    # Use existing secret for API token
    # Secret must have key: api-token
    existingSecret: ""

    # Cloudflare Zone IDs (optional - auto-detected from domain if not set)
    # Useful when you have multiple zones or zone name differs from domain
    # Format: map of domain -> zone ID
    # zoneIds:
    #   example.com: "abc123..."
    zoneIds: {}

    # Proxied records (Cloudflare orange cloud)
    # Only affects A/CNAME records, TXT records are never proxied
    proxied: false

  # === PTR (Reverse DNS) Management ===
  # Automatic PTR record configuration for mail server IPs.
  # Required for proper email delivery - receiving servers check PTR records.
  # PTR must match mail hostname (forward-confirmed reverse DNS).
  ptr:
    # Enable PTR record management
    enabled: false

    # PTR provider: "hetzner" (Cloud), "hetzner-robot" (Dedicated)
    # Each provider has its own configuration section below
    provider: hetzner

    # Hostname for PTR record (default: mail.hostname)
    # Must resolve to the same IP (forward-confirmed reverse DNS)
    hostname: ""

    # IP detection mode:
    # - "auto": Detect from LoadBalancer Service status
    # - "static": Use staticIp value below
    ipMode: "auto"

    # Static IP for PTR (when ipMode: static)
    staticIp: ""

    # Update PTR on every helm upgrade (not just install)
    # Useful when IP changes frequently
    updateOnUpgrade: true

  # === Hetzner Cloud Provider ===
  # Used for PTR record management via Hetzner Cloud API.
  # Works with: Server IPs, Primary IPs, Floating IPs.
  # Does NOT work with Load Balancer IPs (use annotation instead).
  hetzner:
    # Hetzner Cloud API Token
    # Create at: https://console.hetzner.cloud/projects/{project}/security/tokens
    # Required permissions: Read & Write (for server/IP management)
    apiToken: ""

    # Use existing secret for API token
    # Secret must have key: api-token
    existingSecret: ""

  # === Hetzner Robot Provider (Dedicated Servers) ===
  # Used for PTR record management on Hetzner dedicated servers.
  # Requires Robot Webservice credentials (different from Cloud API).
  hetznerRobot:
    # Robot Webservice username
    # Create at: https://robot.your-server.de/preferences/index -> Webservice
    username: ""

    # Robot Webservice password
    password: ""

    # Use existing secret for credentials
    # Secret must have keys: username, password
    existingSecret: ""

  # external-dns integration (when provider: external-dns)
  externalDns:
    # Create DNSEndpoint custom resource
    enabled: false

  # Which records to create
  records:
    a: true # A record for mail hostname
    mx: true # MX record for domains
    spf: true # SPF TXT record
    dkim: true # DKIM TXT record (requires dkim.enabled)
    dmarc: true # DMARC TXT record

  # SPF policy: -all (hard fail), ~all (soft fail), ?all (neutral)
  spfPolicy: "~all"

  # DMARC policy: none, quarantine, reject
  dmarcPolicy: none

  # DMARC pct: percentage of messages to apply policy (1-100)
  # When inbound.dmarcReports.enabled=true, defaults to 100 for full visibility
  # Empty = not added to record (RFC default is 100)
  dmarcPct: ""

  # DMARC aggregate report address (empty = postmaster@domain)
  dmarcRua: ""

  # TTL for DNS records in seconds (default: 5 minutes)
  ttl: 300

  # IP change watcher sidecar
  watcher:
    # Enable IP change monitoring sidecar
    enabled: true

    # Interval between IP checks (seconds)
    interval: 60

    # Timeout waiting for LoadBalancer IP (seconds)
    # Set to 0 to fail immediately if LB IP not ready
    waitForLbTimeout: 300

  # Wait for DNS propagation before starting Haraka
  waitForRecords:
    # Enable DNS verification init container
    enabled: true

    # Which records to verify before starting
    records:
      a: true # Wait for A record
      dkim: true # Wait for DKIM TXT record
      spf: false # SPF is less critical

    # Maximum time to wait for DNS propagation (seconds)
    timeout: 600

    # Interval between DNS checks (seconds)
    interval: 10

    # Custom DNS server for verification (empty = system default)
    # Useful to check authoritative nameserver directly
    dnsServer: ""

# === Service Configuration ===
# Flexible array of services - create any number with any type
#
# Each service can have:
# - name: Optional suffix (empty = use release name, otherwise: {release}-{name})
# - type: ClusterIP, NodePort, LoadBalancer
# - port: Service port (what clients connect to)
# - targetPort: Container port (Haraka listen port)
# - proxyProtocol: Whether this port expects PROXY protocol headers
# - nodePort: For NodePort type
# - loadBalancerIP, loadBalancerClass, loadBalancerSourceRanges: For LoadBalancer type
# - annotations: Service-specific annotations
#
# IMPORTANT: Each unique targetPort creates a Haraka listener.
# Ports with proxyProtocol: true will expect PROXY headers.
# Configure haraka.proxyProtocol.trustedProxies to match LB backend IPs.
#
# Example multi-service setup:
# services:
#   - name: ""           # Main service: {release}-mail-relay
#     type: LoadBalancer
#     port: 25
#     targetPort: 25
#     proxyProtocol: true
#     loadBalancerClass: "hcloud"
#
#   - name: internal     # Internal service: {release}-mail-relay-internal
#     type: ClusterIP
#     port: 25
#     targetPort: 2525   # Different port, no PROXY protocol
#     proxyProtocol: false
#
services:
  - name: "" # Empty = use fullname without suffix
    type: ClusterIP
    port: 25
    targetPort: 25
    proxyProtocol: false
    nodePort: "" # For NodePort type
    loadBalancerIP: "" # For LoadBalancer type
    loadBalancerClass: "" # For LoadBalancer type (e.g., "hcloud")
    loadBalancerSourceRanges: [] # For LoadBalancer type
    # externalTrafficPolicy: Local or Cluster (LoadBalancer/NodePort only)
    # Use "Local" to preserve source IP with PROXY protocol
    externalTrafficPolicy: ""
    annotations: {}
    # Examples:
    #   service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
    #   metallb.universe.tf/loadBalancerIPs: "192.168.1.100"
    # Extra ports on the same service (for multi-port LoadBalancer)
    # Example for TLS on ports 25 (STARTTLS) + 465 (implicit TLS):
    # extraPorts:
    #   - name: smtps
    #     port: 465
    #     targetPort: 465
    extraPorts: []

# === Persistence ===
persistence:
  # Enable persistent storage for mail queue
  enabled: true
  size: 1Gi
  storageClass: ""
  accessModes:
    - ReadWriteOnce
  # Use existing PVC
  existingClaim: ""

# === Network Policy ===
networkPolicy:
  # Enable network policy to restrict ingress
  enabled: false

  # CIDRs allowed to connect to SMTP port
  allowedCidrs: []
  # Example:
  # allowedCidrs:
  #   - 10.0.0.0/8

# === Pod Lifecycle ===
# Time for containers to shutdown gracefully after SIGTERM
# Kubernetes sends SIGKILL after this period
# Default: 30 seconds
terminationGracePeriodSeconds: 30

# === Security Context ===
podSecurityContext:
  fsGroup: 1000

securityContext:
  runAsNonRoot: true
  runAsUser: 1000
  runAsGroup: 1000

# === Resources ===
resources: {}
  # requests:
  #   cpu: 100m
  #   memory: 128Mi
  # limits:
  #   cpu: 500m
  #   memory: 512Mi

# === Scheduling ===
nodeSelector: {}
tolerations: []
affinity: {}

# Pod anti-affinity to spread instances across nodes
# Useful for NodePort scenarios to avoid port conflicts on same node
podAntiAffinity:
  # Enable anti-affinity rules
  enabled: false

  # Type: "hard" (required) or "soft" (preferred)
  # Hard: pod won't schedule if no suitable node available
  # Soft: scheduler will try to spread but won't fail
  type: soft

  # Topology key for spreading
  # kubernetes.io/hostname = spread across nodes (default)
  # topology.kubernetes.io/zone = spread across zones
  topologyKey: kubernetes.io/hostname

  # Custom instance group label value
  # Pods with same group won't be scheduled on the same node
  # Default uses chart name: all mail-relay instances are anti-affined
  # Set different values to allow some instances to coexist
  instanceGroup: ""

# === Service Account ===
serviceAccount:
  create: true
  name: ""
  annotations: {}

# === Pod Metadata ===
podAnnotations: {}
podLabels: {}

# === TLS/SSL Configuration ===
# Enables STARTTLS and implicit TLS for SMTP connections
tls:
  # Enable TLS support (STARTTLS)
  enabled: false

  # Use existing Kubernetes TLS secret (e.g., from cert-manager)
  # Secret must contain tls.crt and tls.key
  # Example: kubectl create secret tls mail-tls --cert=cert.pem --key=key.pem
  existingSecret: ""

  # Auto-generate self-signed certificate if no existingSecret provided
  # Useful for internal relay or testing. NOT recommended for production!
  # Self-signed certs will cause TLS warnings on external mail servers.
  selfSigned:
    enabled: false
    # Common Name for self-signed certificate
    # Defaults to mail.hostname if not set
    cn: ""
    # Validity period in days
    validDays: 365

  # cert-manager integration
  # Automatically creates Certificate resource for Let's Encrypt or other issuers
  # Requires cert-manager to be installed in the cluster
  certManager:
    # Enable cert-manager Certificate creation
    # When enabled, creates Certificate resource and sets existingSecret automatically
    enabled: false

    # Issuer reference (ClusterIssuer or Issuer)
    issuerRef:
      # Name of the issuer (e.g., "letsencrypt-prod", "letsencrypt-staging")
      name: "letsencrypt-prod"
      # Kind: ClusterIssuer (cluster-wide) or Issuer (namespace-scoped)
      kind: "ClusterIssuer"
      # Group (optional, defaults to cert-manager.io)
      group: ""

    # Additional DNS names for the certificate (beyond mail.hostname)
    # Example: ["smtp.example.com", "mail2.example.com"]
    additionalDnsNames: []

    # Certificate duration (default: 2160h = 90 days)
    duration: ""

    # Renew before expiration (default: 360h = 15 days)
    renewBefore: ""

    # Private key settings
    privateKey:
      # Algorithm: RSA, ECDSA, Ed25519
      algorithm: "RSA"
      # Size: 2048, 4096 for RSA; 256, 384, 521 for ECDSA
      size: 2048

  # TLS cipher list (OpenSSL format)
  # Default: modern secure ciphers
  # Empty = Haraka default
  ciphers: ""

  # Minimum TLS version: TLSv1.2, TLSv1.3
  # TLSv1.2 recommended for compatibility, TLSv1.3 for maximum security
  minVersion: "TLSv1.2"

  # Implicit TLS port (direct TLS without STARTTLS)
  # Standard port is 465 (smtps). Set to enable implicit TLS listener.
  # Requires adding a service with this targetPort.
  implicitTlsPort: ""

  # Require TLS for all connections (reject plaintext SMTP)
  # WARNING: Breaks compatibility with servers that don't support TLS
  # Only enable if all your clients support STARTTLS
  requireTls: false

  # Advertise STARTTLS to non-relaying connections (external senders)
  # When false, only relay clients see STARTTLS option
  # Recommended: true (allows external TLS connections)
  advertiseToAll: true

# === SMTP Authentication ===
auth:
  # Enable SMTP AUTH (AUTH PLAIN/LOGIN)
  # When enabled, clients can authenticate to relay mail
  enabled: false

  # Authentication methods to advertise
  # Supported: PLAIN, LOGIN, CRAM-MD5
  methods: "PLAIN,LOGIN"

  # Require TLS before allowing authentication
  # Should be true in production (prevents password sniffing)
  requireTls: true

  # Constrain sender to authenticated username
  # When true: MAIL FROM must match or be subdomain of authenticated user
  # Prevents authenticated users from spoofing other senders
  constrainSender: true

  # User credentials (username: password)
  # Use existingSecret in production!
  users: {}
  # Example:
  # users:
  #   sender@example.com: "secretpassword"
  #   app1@example.com: "app1password"

  # Use existing secret for credentials
  # Secret format: each key is username, value is password
  # Example: kubectl create secret generic haraka-auth --from-literal=user@example.com=password
  existingSecret: ""

# === Inbound Mail Handling (Gateway Mode) ===
# When enabled, server accepts specific addresses for local processing
# (bounces, feedback loops, postmaster). Otherwise, pure relay mode.
#
# Flow:
# 1. Outbound: Client sends X-Message-ID header → we set VERP Return-Path
# 2. Bounce comes in: To bounce+{msg_id}@domain → we extract msg_id
# 3. FBL comes in: Contains X-Haraka-MsgID header → we extract msg_id
# 4. Webhook sent with original message_id for correlation
inbound:
  # Enable gateway mode (accept bounces/FBL)
  enabled: false

  # === Inbound Security (SPF/DKIM/DMARC verification) ===
  # Only applied to inbound mail (not relayed outbound)
  security:
    # SPF (Sender Policy Framework) verification
    spf:
      # Enable SPF checking on inbound mail
      enabled: true
      # Reject mail that fails SPF (sender's IP not authorized)
      # Honors the sender domain's SPF policy (-all = hard fail)
      rejectFail: true
      # Reject mail with SPF softfail (~all)
      # Set to false to only reject hard fails (-all)
      rejectSoftfail: false

    # DKIM signature verification
    dkim:
      # Verify DKIM signatures on inbound mail
      # Adds Authentication-Results header
      enabled: true

    # DMARC verification (checks SPF/DKIM alignment with From header)
    dmarc:
      # Enable DMARC verification
      enabled: true
      # Honor sender domain's DMARC policy
      # When true: reject if domain has p=reject and check fails
      rejectOnFail: true
      # Honor quarantine policy (add X-Quarantine header)
      # When true: mark message if domain has p=quarantine and check fails
      quarantineOnFail: true

  # Header to read client message ID from (for VERP and tracking)
  # Client should include this header when sending email
  # Example: X-Message-ID: order-12345
  clientIdHeader: "X-Message-ID"

  # Addresses to accept for local processing
  # Patterns ending with "+" match prefix (VERP-style)
  recipients:
    - postmaster
    - abuse
    - "bounce+" # Accepts bounce+anything@domain (VERP)
    - fbl
    - dmarc # DMARC aggregate reports (rua=mailto:dmarc@domain)

  # Bounce processing settings
  bounce:
    # Enable bounce validation plugin
    enabled: true
    # VERP prefix for tracking original recipient
    # Creates Return-Path: bounce+{timestamp}-{hmac}-{message_id}@domain
    verpPrefix: "bounce+"
    # Use sender's domain for bounce Return-Path if it's in mail.domains list
    # sender@domain1.com → bounce+{id}@domain1.com (if domain1.com is configured)
    # If sender's domain is not in the list, falls back to mail.hostname
    useSenderDomain: true
    # HMAC secret for VERP signature (auto-generated at runtime if empty)
    # Protects against forged/spam bounce attacks
    # IMPORTANT: Set this to a stable secret in production!
    hmacSecret: ""
    # Require HMAC validation on incoming bounces
    # When true, rejects bounces without valid HMAC signature
    # Set to false during migration from non-HMAC setup
    requireHmac: true
    # Maximum age of valid bounces in days
    # Bounces older than this are rejected (protection against replay attacks)
    maxAgeDays: 7

  # === DMARC Aggregate Reports ===
  # Parse DMARC aggregate reports (RFC 7489) and export statistics to Prometheus
  # Reports are XML files sent by email providers to the address in DMARC rua= tag
  # Example DMARC record: v=DMARC1; p=reject; rua=mailto:dmarc@example.com
  dmarcReports:
    # Enable DMARC report processing (accepts mail to dmarc@domain)
    enabled: false

    # Port for DMARC-specific Prometheus metrics endpoint
    # Provides: haraka_dmarc_reports_total, haraka_dmarc_messages_total, etc.
    metricsPort: 8094

    # Store parsed reports to disk (JSON format)
    storeReports: false
    storePath: /data/dmarc-reports

    # Maximum report age to process (days, 0=unlimited)
    # Old reports are accepted but not processed (prevents metric pollution)
    maxReportAge: 90

    # Send webhook for each parsed DMARC report
    webhook:
      enabled: false
      url: ""
      timeout: 5000

# === Metrics / Monitoring ===
metrics:
  # Enable Prometheus metrics endpoint
  enabled: false

  serviceMonitor:
    # Create ServiceMonitor for Prometheus Operator
    enabled: false
    interval: 30s
    # Labels for ServiceMonitor (Prometheus Operator requires selector match)
    # Default includes "release: monitoring" for standard kube-prometheus-stack
    labels:
      release: monitoring

# === Web Dashboard ===
dashboard:
  # Haraka Watch plugin - real-time SMTP traffic monitoring
  watch:
    enabled: false
    # Limit display to 1 connection per second (for high-traffic servers)
    sampling: false

  # Log reader plugin - view per-connection logs
  logReader:
    enabled: false

  # HTTP server port for dashboard and metrics
  port: 8080

  # Grafana dashboard auto-import
  grafana:
    # Create ConfigMap with dashboard JSON
    enabled: false
    # Labels for Grafana sidecar discovery
    labels:
      grafana_dashboard: "1"

# === Redis (required for Watch Dashboard with multiple workers) ===
redis:
  enabled: false
  # External Redis server
  host: ""
  port: 6379
  # Optional password
  password: ""
  # Use existing secret for password
  # Secret must have key: password
  existingSecret: ""
  # Database number
  db: 0

# === Webhooks (Delivery Events) ===
webhooks:
  # Enable delivery event webhooks
  enabled: false

  # Multiple webhook endpoints
  # Each endpoint can have its own URL, events, and headers
  #
  # Available events:
  # - delivered: Email successfully delivered to remote MX
  # - bounced: Synchronous bounce (rejected during SMTP session)
  # - deferred: Email temporarily deferred (4xx response)
  # - bounce_received: Async bounce (DSN received later) [requires inbound.enabled]
  # - complaint: FBL spam complaint received [requires inbound.enabled]
  endpoints: []
  # Example:
  # endpoints:
  #   - name: main-webhook
  #     url: "https://api.example.com/webhooks/email"
  #     events:
  #       - delivered
  #       - bounced
  #       - bounce_received
  #       - complaint
  #     headers:
  #       Authorization: "Bearer token123"
  #   - name: analytics
  #     url: "http://localhost:8888/webhook"
  #     events:
  #       - delivered
  #       - bounced
  #       - deferred

  # Global settings (applied to all endpoints)
  timeout: 5000
  retry: true
  maxRetries: 3

# === Blacklist Monitoring ===
# Monitors mail relay IP and domains against DNS-based blacklists
# Sends alerts via email, webhooks, and exposes Prometheus metrics
blacklist:
  # Enable blacklist monitoring sidecar
  enabled: true

  # Check interval in seconds (default: 1 hour)
  # Lower values increase DNS queries but catch listings faster
  interval: 3600

  # Prometheus metrics port
  metricsPort: 8095

  # === DNS Configuration ===
  # Many premium DNSBLs (Spamhaus, URIBL, SURBL, SenderScore) block queries
  # from public DNS resolvers (Google 8.8.8.8, Cloudflare 1.1.1.1).
  #
  # Options:
  # 1. Use directQuery: true - query authoritative NS directly (recommended)
  # 2. Use freeOnly: true - only check DNSBLs that work with public resolvers
  # 3. Set dnsServer to your own recursive resolver (unbound, CoreDNS, bind)
  # 4. Use paid subscription (Spamhaus DQS, URIBL Data Feed)

  # Custom DNS server for premium DNSBL queries
  # Example: "10.96.0.10" (CoreDNS in cluster) or your own unbound
  dnsServer: ""

  # Direct query mode - query authoritative nameservers directly
  # This bypasses public DNS resolvers and works with premium DNSBLs
  # like Spamhaus without needing a custom DNS server or subscription
  directQuery: true

  # Only use free DNSBLs that work with public resolvers
  # When true: checks 25 IP lists and 6 domain lists
  # When false: checks all lists (37 IP + 12 domain) but needs directQuery or dnsServer
  freeOnly: false

  # === IP Blacklists (DNSBL/RBL) ===
  # Full list matching MXToolbox coverage (60+ lists)
  # Uses reverse-IP lookup: 4.3.2.1.dnsbl.example.org
  ipLists:
    # Critical - most widely used
    - zen.spamhaus.org # Spamhaus ZEN (SBL+XBL+PBL)
    - b.barracudacentral.org # Barracuda Central
    - bl.spamcop.net # SpamCop

    # Major providers
    - dnsbl.sorbs.net # SORBS aggregate
    - dnsbl-1.uceprotect.net # UCEProtect Level 1
    - dnsbl-2.uceprotect.net # UCEProtect Level 2
    - dnsbl-3.uceprotect.net # UCEProtect Level 3
    - psbl.surriel.com # Passive Spam Block List

    # SpamRATS
    - dyna.spamrats.com # SpamRATS Dynamic
    - noptr.spamrats.com # SpamRATS No PTR
    - spam.spamrats.com # SpamRATS Spam

    # Mailspike
    - bl.mailspike.net # Mailspike BL
    - z.mailspike.net # Mailspike Z

    # 0SPAM
    - bl.0spam.org # 0SPAM RBL

    # Abusix Mail Intelligence
    - combined.mail.abusix.zone # Abusix Combined
    - dblack.mail.abusix.zone # Abusix Domain Blacklist
    - exploit.mail.abusix.zone # Abusix Exploit list

    # Various providers
    - anonmails.de # Anonmails DNSBL
    - ips.backscatterer.org # Backscatterer
    - bl.blocklist.de # Blocklist.de
    - bogons.cymru.com # CYMRU Bogons
    - torexit.dan.me.uk # DAN TOR Exit
    - tor.dan.me.uk # DAN TOR
    - rbl.dns-servicios.com # DRMX
    - drone.abuse.ch # Drone BL
    - bl.fabel.dk # Fabelsources
    - hil.habeas.com # HIL
    - hil2.habeas.com # HIL2
    - hostkarma.junkemailfilter.com # Hostkarma Black
    - dnsbl.ibm.com # IBM DNS Blacklist
    - icm.your-server.de # ICMFORBIDDEN
    - spamlist.or.kr # IMP SPAM
    - wormlist.or.kr # IMP WORM
    - rbl.interserver.net # Interserver
    - dnsbl.inps.de # ivmSIP
    - dnsbl24.inps.de # ivmSIP24
    - mail-abuse.blacklist.jippg.org # JIPPG
    - rbl.kempt.net # KEMPTBL
    - bl.konstant.no # Konstant
    - rbl.lashback.com # Lashback
    - phishing.rbl.msrbl.net # MSRBL Phishing
    - spam.rbl.msrbl.net # MSRBL Spam
    - relays.nether.net # NETHERRELAYS
    - unsure.nether.net # NETHERUNSURE
    - bl.nordspam.com # Nordspam BL
    - bl.nosolicitado.org # NoSolicitado
    - all.s5h.net # s5h.net
    - rbl.schulte.org # SCHULTE
    - backscatter.spameatingmonkey.net # SEM Backscatter
    - bl.spameatingmonkey.net # SEM Black
    - bl.servicesspc.com # SERVICESNET
    - bl.suomispam.net # Suomispam
    - dnsrbl.swinog.ch # SWINOG
    - mail-abuse.rbl.triumf.ca # TRIUMF
    - truncate.gbudb.net # TRUNCATE
    - dnsbl.zapbl.net # ZapBL
    - db.wpbl.info # Woodys SMTP Blacklist

  # Additional custom IP blacklists
  customIpLists: []

  # === Domain Blacklists (URIBL/DBL) ===
  # Checks sending domains against URI/domain blacklists
  # Uses direct lookup: example.com.dbl.spamhaus.org
  domainLists:
    - dbl.spamhaus.org # Spamhaus Domain Block List (most important)
    - multi.surbl.org # SURBL Multi
    - multi.uribl.com # URIBL Multi
    - black.uribl.com # URIBL Black
    - grey.uribl.com # URIBL Grey
    - rhsbl.sorbs.net # SORBS RHSBL
    - dbl.nordspam.com # Nordspam DBL
    - dbl.suomispam.net # Suomispam DBL
    - rhsbl.zapbl.net # ZapBL RHSBL
    - dbl.abuseat.org # Abuseat DBL
    - fresh.spameatingmonkey.net # SEM Fresh Domains
    - fresh15.spameatingmonkey.net # SEM Fresh 15-day

  # Additional custom domain blacklists
  customDomainLists: []

  # Domains to check (in addition to mail.domains which are auto-added)
  # Leave empty to only check domains from mail.domains
  additionalDomains: []

  # Email alerts when IP/domain is found on blacklist
  alerts:
    # Enable email notifications
    enabled: false

    # Recipients for blacklist alerts
    recipients: []
    # Example:
    # recipients:
    #   - admin@example.com
    #   - ops-team@example.com

    # Sender address for alerts (should be in mail.domains)
    # Default: blacklist-monitor@{first domain}
    from: ""

    # Subject line prefix
    subjectPrefix: "[BLACKLIST ALERT]"

    # Cooldown between alerts for same IP/domain/blacklist (hours)
    # Prevents alert spam when target stays listed
    cooldownHours: 24

    # SMTP settings for sending alerts
    # Default: use localhost (the mail relay itself)
    smtp:
      host: "localhost"
      port: 25

  # Webhook notifications
  webhook:
    # Enable webhook notifications
    enabled: false

    # Webhook URL (receives POST with JSON payload)
    url: ""
    # Example:
    # url: "https://hooks.slack.com/services/xxx"
    # url: "https://api.pagerduty.com/events"

    # Request timeout in seconds
    timeout: 5

    # Custom headers (e.g., for authentication)
    headers: {}
    # Example:
    # headers:
    #   Authorization: "Bearer token123"

  # Resource limits for blacklist sidecar
  resources:
    requests:
      cpu: 10m
      memory: 32Mi
    limits:
      cpu: 50m
      memory: 64Mi

# === Extra Sidecars ===
# Add custom sidecar containers to the pod
# Useful for debugging, log shipping, metrics collection, etc.
sidecars: []
# Example - HTTP echo server for webhook debugging:
# sidecars:
#   - name: webhook-echo
#     image: mendhak/http-https-echo:33
#     ports:
#       - name: http
#         containerPort: 8888
#     env:
#       - name: HTTP_PORT
#         value: "8888"
#     resources:
#       requests:
#         cpu: 10m
#         memory: 32Mi
#       limits:
#         cpu: 100m
#         memory: 64Mi
